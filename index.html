<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Avatar Group</title>
        <!-- Import IBM Plex Sans font -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@700&display=swap" rel="stylesheet">

        <style>
            /* --- General Page Style --- */
            body {
                background-color: #260A2F;
                /* align-items: center; REMOVED - Flexbox on hero handles centering */
                min-height: 100vh;
                padding: 60px 20px;
                /* Keeps padding around the whole page */
                box-sizing: border-box;
                font-family: 'IBM Plex Sans', sans-serif;
                margin: 0;
                color: #FFFFFF;
                display: flex;
                /* Make body a flex container */
                flex-direction: column;
                /* Stack children (hero, scrollable) vertically */
            }

            /* --- Hero Content Styling --- */
            .hero-content {
                font-size: 4rem;
                /* Base size for desktop */
                font-weight: bold;
                line-height: 1.2;
                letter-spacing: -0.02em;
                text-align: left;
                max-width: 1200px;
                /* Optional: constrain max width on large screens */
                width: 100%;
                /* Take available width */
                /* --- START Modifications for 50vh Height & Centering --- */
                height: 50vh;
                /* Set height to 50% of viewport height */
                display: flex;
                /* Enable Flexbox */
                flex-direction: column;
                /* Stack lines vertically */
                justify-content: center;
                /* Vertically center the lines within the 50vh */
                margin-left: auto;
                /* Horizontally center the block when max-width is hit */
                margin-right: auto;
                /* Horizontally center the block when max-width is hit */
                flex-shrink: 0;
                /* Prevent hero from shrinking if content below grows */
                /* --- END Modifications --- */
            }

            /* --- Styles for lines within hero remain largely the same --- */
            .hero-content .line-1 {
                display: flex;
                align-items: baseline;
                flex-wrap: wrap;
                /* Allow wrapping on smaller screens */
                margin-bottom: 0.1em;
            }

            .hero-content .line-2,
            .hero-content .line-3,
            .hero-content .line-4 {
                margin-bottom: 0.1em;
                /* Allow wrapping for individual lines too if needed */
                word-break: break-word;
            }

            .hero-content .inline-block {
                display: inline-block;
                vertical-align: middle;
                /* Keeps vertical alignment */
                margin: 0 0.2em;
                /* Adjust spacing */
                position: relative;
                /* Ensure it doesn't cause excessive line height issues */
                line-height: 1;
            }

            .hero-content .spark-svg {
                display: inline-block;
                vertical-align: baseline;
                width: 0.8em;
                /* Scales with font size */
                height: 0.8em;
                /* Scales with font size */
                margin: 0 0.05em;
                position: relative;
                top: -0.05em;
                /* Adjust vertical position relative to baseline */
            }

            .hero-content .text-orange {
                color: #FF4F00;
            }

            /* --- Scrollable Content Styling --- */
            .scrollable-content {
                /* Allow this section to take remaining space and scroll if needed */
                flex-grow: 1;
                overflow-y: auto;
                /* Add scroll if content exceeds available space */
                max-width: 1200px;
                /* Match hero max-width */
                width: 100%;
                /* Take available width */
                margin-left: auto;
                /* Center the content block */
                margin-right: auto;
                /* Center the content block */
                padding-top: 2em;
                /* Add some space above the scrollable text */
            }

            .scrollable-content p {
                font-family: sans-serif;
                font-weight: normal;
                font-size: 1rem;
                /* Use rem for better accessibility */
                line-height: 1.7;
                /* margin-top: 4em; REMOVED - Space handled by scrollable-content padding */
                margin-bottom: 1.5em;
                color: #fff;
                /* Slightly softer white for paragraph text */
            }

            .scrollable-content h2 {
                margin-top: 2em;
                /* Space above heading */
                margin-bottom: 1em;
                /* Space below heading */
            }


            /* --- Avatar Group Styling --- */
            /* ... (Existing avatar styles remain unchanged) ... */
            :root {
                /* Core Dimensions & Layout */
                --avatar-size: 72px;
                --avatar-overlap: 20px;
                --visible-avatars: 3;
                --container-padding: 0px;
                /* Keep for consistency, though 0 */

                /* Border & Background Settings */
                --background-color-outer: #FF4F00;
                --border-color-outer: #FFE0CC;
                --border-width-outer: 4px;
                --background-color-inner: #FF4F00;
                /* Background for avatar item before image loads */
                --avatar-stroke-color: #FF4F00;
                /* Border around each avatar item */
                --avatar-border-thickness: 6px;
                /* Thickness of the border around each avatar */
                --viewport-overlay-border-width: 6px;
                /* Thickness of the inner viewport border */
                --viewport-overlay-border-color: #FF4F00;
                /* Color of the inner viewport border */

                /* Concentric Border Radii - calculated to maintain curve */
                --border-radius-outer: 20px;
                --border-radius-viewport: max(0px, calc(var(--border-radius-outer) - var(--border-width-outer) - var(--container-padding)));
                --border-radius-avatar-item: max(0px, var(--border-radius-viewport));
                --border-radius-avatar-image: max(0px, calc(var(--border-radius-avatar-item) - var(--avatar-border-thickness)));

                /* Derived Layout Calculations */
                --avatar-slot-width: calc(var(--avatar-size) - var(--avatar-overlap));
                --viewport-width: calc(var(--avatar-size) + (var(--visible-avatars) - 1) * var(--avatar-slot-width));

                /* Plus Count Appearance */
                --text-color-count: #FFFFFF;
                --font-size-count: 26px;
                --count-margin-left: 10px;
            }

            .avatar-group-container {
                display: flex;
                align-items: center;
                padding: var(--container-padding);
                background-color: var(--background-color-outer);
                border-radius: var(--border-radius-outer);
                border: var(--border-width-outer) solid var(--border-color-outer);
                width: fit-content;
                /* Adapts to viewport width + count */
                cursor: default;
                /* Default cursor, interaction is hover only */
                box-sizing: border-box;
                overflow: hidden;
                /* Clips the outer border radius */
                position: relative;
            }

            .avatar-viewport {
                width: var(--viewport-width);
                /* Calculated width based on visible avatars */
                height: var(--avatar-size);
                overflow: hidden;
                /* Clips the avatars scrolling inside */
                border-radius: var(--border-radius-viewport);
                /* Inner border radius */
                position: relative;
                /* For pseudo-element positioning */
                box-sizing: border-box;
            }

            .avatar-viewport::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                border-radius: inherit;
                /* Takes radius from .avatar-viewport */
                border: var(--viewport-overlay-border-width) solid var(--viewport-overlay-border-color);
                box-sizing: border-box;
                /* Border included in element dimensions */
                pointer-events: none;
                /* Allows clicks/hovers to pass through */
                z-index: 10;
                /* Sits above avatar items but below count */
            }

            .avatar-scroller {
                display: flex;
                height: 100%;
                will-change: transform;
                /* Hint for performance */
                box-sizing: border-box;
                position: relative;
                /* Needed for transform */
                transform: translateX(0);
                /* Initial position */
            }

            .avatar-scroller.snapping {
                transition: transform 0.5s cubic-bezier(0.66, 0.8, 0.66, 1);
            }

            .avatar-item {
                width: var(--avatar-size);
                height: var(--avatar-size);
                flex-shrink: 0;
                /* Prevent avatars from shrinking */
                margin-right: calc(-1 * var(--avatar-overlap));
                border-radius: var(--border-radius-avatar-item);
                overflow: hidden;
                /* Clips the image inside */
                background-color: var(--background-color-inner);
                box-sizing: border-box;
                display: flex;
                justify-content: center;
                align-items: center;
                border: var(--avatar-border-thickness) solid var(--avatar-stroke-color);
                position: relative;
                opacity: 1;
                transition: transform 0.5s;
                /* Opacity transition handled separately */
                pointer-events: auto;
            }

            .avatar-item.is-partially-hidden {
                opacity: 0;
                pointer-events: none;
            }

            .avatar-item img {
                display: block;
                width: 100%;
                height: 100%;
                object-fit: cover;
                object-position: center center;
                border-radius: var(--border-radius-avatar-image);
                overflow: hidden;
            }

            .avatar-plus-count {
                color: var(--text-color-count);
                font-size: var(--font-size-count);
                font-weight: 700;
                /* Match hero font weight */
                margin-left: var(--count-margin-left);
                margin-right: 16px;
                /* Fixed spacing on the right */
                white-space: nowrap;
                pointer-events: none;
                user-select: none;
                box-sizing: border-box;
                z-index: 50;
            }

            /* --- End Avatar Group Styling --- */

            /* --- Responsive Adjustments --- */
            @media (max-width: 768px) {
                body {
                    padding: 40px 15px;
                    /* Reduce padding on smaller screens */
                }

                .hero-content {
                    font-size: 2.5rem;
                    /* Reduce font size significantly */
                    height: auto;
                    /* Let height be determined by content on smaller screens */
                    min-height: 40vh;
                    /* Ensure it still takes up significant space */
                    padding: 2em 0;
                    /* Add some vertical padding instead of fixed height */
                }

                .hero-content .inline-block {
                    margin: 0.2em 0.15em;
                    /* Adjust spacing around avatar/spark */
                    /* Add vertical margin if it wraps to its own line */
                    margin-bottom: 0.4em;
                }

                .scrollable-content {
                    padding-top: 1.5em;
                    /* Adjust space */
                }

                /* Adjust avatar size and count font on smaller screens if needed */
                :root {
                    /* Example: Optionally reduce avatar size on mobile */
                    /* --avatar-size: 60px; */
                    /* --avatar-overlap: 15px; */
                    /* --font-size-count: 22px; */
                }
            }

            @media (max-width: 480px) {
                body {
                    padding: 30px 10px;
                    /* Further reduce padding */
                }

                .hero-content {
                    font-size: 2rem;
                    /* Further reduce font size */
                    min-height: 35vh;
                    padding: 1.5em 0;
                }

                /* Further adjustments if needed for very small screens */
                :root {
                    /* Example: Further reduce avatar size */
                    --avatar-size: 56px;
                    --avatar-overlap: 15px;
                    --font-size-count: 20px;
                    --border-radius-outer: 16px;
                    /* Slightly smaller radius */
                    --avatar-border-thickness: 4px;
                    --viewport-overlay-border-width: 4px;
                }

                .avatar-plus-count {
                    margin-right: 10px;
                    /* Reduce right margin */
                }

                .scrollable-content {
                    padding-top: 1em;
                    /* Adjust space */
                }

                .scrollable-content p {
                    font-size: 0.95rem;
                    /* Slightly smaller text on very small screens */
                }
            }
        </style>
    </head>

    <body>
        <div class="hero-content">
            <div class="line-1">
                <span>Wir</span>
                <div class="inline-block">
                    <!-- Avatar Group Component -->
                    <div class="avatar-group-container" id="interactiveAvatarGroup">
                        <div class="avatar-viewport">
                            <div class="avatar-scroller">
                                <!-- Avatars dynamically added here -->
                            </div>
                        </div>
                        <div class="avatar-plus-count" id="avatarCount">+25</div>
                    </div>
                    <!-- End Avatar Group Component -->
                </div>
                <span>verwandeln</span>
            </div>
            <div class="line-2">
                <span>deine</span>
                <svg class="spark-svg" viewBox="0 0 57 56" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd"
                          d="M0.919922 26.8242C14.0381 23.4473 24.3672 13.1159 27.7441 0H30.0957C33.4727 13.1159 43.8018 23.4473 56.9199 26.8242V29.1758C43.8018 32.5527 33.4727 42.8841 30.0957 56H27.7441C24.3672 42.8796 14.0392 32.5527 0.919922 29.1758V26.8242Z"
                          fill="#FF4F00" />
                </svg>
                <span class="text-orange">komplexen</span>
            </div>
            <div class="line-3">
                <span class="text-orange">Herausforderungen</span> <span>in</span>
            </div>
            <div class="line-4">
                <span>digitale Lösungen</span>
            </div>
        </div>

        <div class="scrollable-content">

            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>
            <p>Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam varius, turpis et commodo pharetra, est eros bibendum
                elit, nec luctus magna felis sollicitudin mauris. Integer in mauris eu nibh euismod gravida.</p>
            <p>Duis ac tellus et risus vulputate vehicula. Donec lobortis risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue, eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas fermentum consequat mi. Donec
                fermentum. Pellentesque malesuada nulla a mi.</p>
            <p>Duis sapien sem, aliquet nec, commodo eget, consequat quis, neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque nunc. Nullam arcu. Aliquam erat
                volutpat. Duis ac turpis. Integer rutrum ante eu lacus.</p>
            <p>Ut cursus et vel nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Mauris pretium lacus et magna. Fusce quis neque vel lectus ultricies suscipit. Sed feugiat. Fusce ut diam. Integer egestas,
                orci quis laoreet dapibus, magna dolor pharetra magna, eu iaculis justo odio quis arcu.</p>
            <p>Nam sed tellus id magna elementum tincidunt. Morbi tincidunt, dui sit amet facilisis feugiat, odio metus gravida ante, ut pharetra massa metus id nunc. Pellentesque scelerisque. Nunc sit amet velit. Integer imperdiet turpis nec elit.
                Proin nec justo. Vivamus luctus, ipsum id venenatis consectetuer, velit augue luctus metus, ac sagittis neque orci sit amet odio.</p>
            <p>Sed sagittis, leo et facilisis lobortis, sapien nibh tempor elit, non eleifend enim magna non nisl. Nullam eleifend placerat lacus. Quisque facilisis suscipit elit. Pellentesque habitant morbi tristique senectus et netus et malesuada
                fames ac turpis egestas. Morbi lectus. Nulla facilisi.</p>
            <p>Vestibulum et metus. Curabitur et felis. Praesent sagittis. Sed aliquet odio vitae tortor. Nunc tincidunt nisi vitae velit. Aliquam erat volutpat. Integer malesuada. Class aptent taciti sociosqu ad litora torquent per conubia nostra,
                per inceptos himenaeos.</p>

        </div>

        <script>
            (function () { // IIFE for encapsulation
                'use strict';

                // --- Configuration & Settings ---
                const SETTINGS = {
                    containerId: 'interactiveAvatarGroup',
                    viewportSelector: '.avatar-viewport',
                    scrollerSelector: '.avatar-scroller',
                    countSelector: '#avatarCount',
                    avatarItemSelector: '.avatar-item',
                    avatarUrls: [ // Example URLs
                        'https://picsum.photos/id/1005/150/150', 'https://picsum.photos/id/1011/150/150', 'https://picsum.photos/id/1012/150/150',
                        'https://picsum.photos/id/1027/150/150', 'https://picsum.photos/id/10/150/150', 'https://picsum.photos/id/20/150/150',
                        'https://picsum.photos/id/30/150/150', 'https://picsum.photos/id/40/150/150',
                        'https://picsum.photos/id/50/150/150', 'https://picsum.photos/id/60/150/150'
                        // Add more URLs as needed
                    ],
                    staticCountText: "+25",      // Text for the count element when scrolling is active. Set to null or empty to hide count.
                    scrollSpeedFactor: 0.15,     // Desktop: Multiplier for hover scroll speed (~pixels per frame target) - ADJUST FOR FEEL
                    easeInDurationMs: 1500,      // Desktop: Duration of the ease-in effect when hover starts (milliseconds)
                    minAvatarsForScroll: 4,      // Minimum total unique avatars needed to enable scrolling behavior
                    // --- Settings for Scroll Interaction ---
                    scrollMultiplier: 0.8,       // Mobile: How much avatar scrolls per pixel of page scroll (adjust for feel)
                    scrollStopDelay: 200,        // Mobile: Milliseconds after last scroll event to trigger snap (NOW UNUSED for snapping, but delay might be useful elsewhere if needed)
                    // --- End Settings ---
                    cssVarDefaults: {            // Fallback values if CSS variables are not readable
                        avatarSize: 72,
                        avatarOverlap: 20,
                        visibleAvatars: 3
                    },
                    // CSS classes used for state management
                    snappingClass: 'snapping',
                    partiallyHiddenClass: 'is-partially-hidden'
                };

                // --- DOM Element References ---
                const container = document.getElementById(SETTINGS.containerId);
                if (!container) {
                    console.error(`Avatar group container with ID "${SETTINGS.containerId}" not found.`);
                    return;
                }
                const viewport = container.querySelector(SETTINGS.viewportSelector);
                const scroller = container.querySelector(SETTINGS.scrollerSelector);
                const countElement = container.querySelector(SETTINGS.countSelector);

                if (!viewport || !scroller || !countElement) {
                    console.error("Required elements (viewport, scroller, count) not found within the container.");
                    return;
                }

                // --- State Variables ---
                let isHovering = false;         // Desktop: Is the mouse currently over the container?
                let isScrollingEnabled = false; // Is the interactive behavior active?
                let isMobileMode = false;       // Is the scroll-driven behavior active?
                let animationFrameId = null;    // ID for cancelling the animation frame loop (hover/scroll update)
                let hoverStartTime = null;      // Desktop: Timestamp when hover began (for easing)
                let currentScrollPosition = 0;  // Tracks the theoretical scroll position (can exceed loop width)
                let renderedAvatarItems = [];   // NodeList of all rendered avatar DOM elements
                let layout = {                  // Stores calculated layout values
                    avatarSize: 0,
                    avatarOverlap: 0,
                    visibleAvatarsCount: 0,
                    avatarSlotWidth: 0,         // Effective width each avatar occupies (size - overlap)
                    scrollerLoopWidth: 0        // Width of one full cycle of unique avatars
                };
                // --- State for Scroll ---
                let previousScrollY = 0;        // Mobile: Stores previous window scroll position
                let scrollTimeoutId = null;     // Mobile: Timeout ID for detecting scroll stop
                let isScrollUpdatePending = false; // Mobile: Flag for rAF scroll update throttling
                let pendingScrollOffset = 0;    // Mobile: The target offset to apply in the next rAF

                // --- Utility Functions ---

                /** Reads a CSS custom property value */
                function getCssVariable(varName, defaultValue) {
                    const value = getComputedStyle(document.documentElement).getPropertyValue(`--${varName}`).trim();
                    const parsedValue = parseInt(value, 10);
                    return !isNaN(parsedValue) ? parsedValue : defaultValue;
                }

                /** Gets the current horizontal translation (translateX) */
                function getCurrentTranslateX(element) {
                    try {
                        const styleTransform = element.style.transform;
                        if (styleTransform && styleTransform.includes('translateX')) {
                            const match = styleTransform.match(/translateX\(([-.\d]+)px\)/);
                            if (match && match[1]) {
                                return parseFloat(match[1]);
                            }
                        }
                        const computedTransform = window.getComputedStyle(element).transform;
                        if (computedTransform && computedTransform !== 'none') {
                            const matrix = new DOMMatrixReadOnly(computedTransform);
                            return matrix.m41;
                        }
                    } catch (e) {
                        console.warn("Could not parse transform matrix:", e);
                    }
                    return 0;
                }

                /** Creates and appends avatar elements */
                function populateAvatars(urls) {
                    const fragment = document.createDocumentFragment();
                    urls.forEach(url => {
                        const item = document.createElement('div');
                        item.className = SETTINGS.avatarItemSelector.substring(1);
                        const img = document.createElement('img');
                        img.src = url;
                        img.alt = 'Team Member Avatar';
                        img.loading = 'lazy';
                        img.draggable = false;
                        item.appendChild(img);
                        fragment.appendChild(item);
                    });
                    scroller.appendChild(fragment);
                    renderedAvatarItems = scroller.querySelectorAll(SETTINGS.avatarItemSelector);
                }

                /** Prepares avatar URLs for rendering (shuffling/duplication) */
                function prepareAvatarUrlsForRender(uniqueUrls) {
                    const totalUniqueAvatars = uniqueUrls.length;
                    let urlsToRender = [...uniqueUrls].sort(() => 0.5 - Math.random());

                    if (isScrollingEnabled) {
                        const requiredCount = layout.visibleAvatarsCount + totalUniqueAvatars;
                        let safetyCounter = 0;
                        const maxSafetyCount = 10;
                        while (urlsToRender.length < requiredCount && safetyCounter < maxSafetyCount) {
                            urlsToRender.push(...[...uniqueUrls].sort(() => 0.5 - Math.random()));
                            safetyCounter++;
                        }
                        if (safetyCounter >= maxSafetyCount) {
                            console.warn("Avatar duplication limit reached. Looping might not be seamless.");
                        }
                    }
                    return urlsToRender;
                }


                // --- Animation & Interaction Logic ---

                /** Easing function (Ease-Out Cubic) */
                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                /** Desktop: Animation loop callback for hover scrolling. */
                function animateHoverScroll() {
                    if (!isHovering || !isScrollingEnabled || isMobileMode) {
                        animationFrameId = null;
                        return;
                    }
                    const currentTime = performance.now();
                    const elapsedTime = currentTime - (hoverStartTime || currentTime);
                    const easeProgress = Math.min(1, elapsedTime / SETTINGS.easeInDurationMs);
                    const easedFactor = easeOutCubic(easeProgress);
                    const currentSpeed = (layout.avatarSlotWidth * SETTINGS.scrollSpeedFactor) * easedFactor;
                    currentScrollPosition += currentSpeed;
                    applyScrollPosition();
                    animationFrameId = requestAnimationFrame(animateHoverScroll);
                }

                /** Mobile: Callback for the rAF used to update scroll position */
                function performScrollUpdate() {
                    if (!isScrollUpdatePending) return; // Already processed or not needed
                    if (layout.scrollerLoopWidth > 0) {
                        // Ensure the visual offset stays within the loop bounds
                        pendingScrollOffset = (currentScrollPosition % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                    } else {
                        pendingScrollOffset = currentScrollPosition; // No loop, just use the raw position
                    }
                    scroller.style.transform = `translateX(-${pendingScrollOffset}px)`;
                    isScrollUpdatePending = false;
                    animationFrameId = null; // Release the lock
                }

                /** Mobile: Schedules a scroll update using requestAnimationFrame */
                function scheduleScrollUpdate() {
                    isScrollUpdatePending = true; // Mark that an update is needed
                    // The calculation of pendingScrollOffset is now done inside performScrollUpdate
                    if (!animationFrameId) { // Only request a new frame if one isn't already pending
                        animationFrameId = requestAnimationFrame(performScrollUpdate);
                    }
                }


                /** Common function to apply the currentScrollPosition visually (used by Desktop hover) */
                function applyScrollPosition() {
                    let visualOffset = 0;
                    if (layout.scrollerLoopWidth > 0) {
                        visualOffset = currentScrollPosition % layout.scrollerLoopWidth;
                        visualOffset = (visualOffset + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                    } else {
                        visualOffset = currentScrollPosition;
                    }
                    scroller.style.transform = `translateX(-${visualOffset}px)`;
                }

                /** Callback function for when the snap transition ends (Desktop only now). */
                function onSnapTransitionEnd() {
                    scroller.classList.remove(SETTINGS.snappingClass);
                    scroller.removeEventListener('transitionend', onSnapTransitionEnd);
                    // Ensure no items are hidden after snap (relevant for desktop)
                    renderedAvatarItems.forEach(item => {
                        item.classList.remove(SETTINGS.partiallyHiddenClass);
                    });
                    // Re-calculate the hidden one based on final snapped position for desktop
                    const finalVisualOffset = getCurrentTranslateX(scroller);
                    const finalSnappedSlotIndex = Math.round(Math.abs(finalVisualOffset) / layout.avatarSlotWidth);
                    const finalHiddenIndex = (finalSnappedSlotIndex + layout.visibleAvatarsCount) % renderedAvatarItems.length;
                    if (renderedAvatarItems[finalHiddenIndex]) {
                        renderedAvatarItems[finalHiddenIndex].classList.add(SETTINGS.partiallyHiddenClass);
                    }

                }

                /** Calculates the target scroll offset for snapping back (Desktop only now). */
                function calculateSnapTargetOffset(currentVisualOffset, direction) {
                    // No snapping on mobile, so this is only relevant for desktop
                    if (isMobileMode || layout.scrollerLoopWidth <= 0 || layout.avatarSlotWidth <= 0) {
                        return currentVisualOffset; // Return current position if mobile or invalid layout
                    }

                    const positiveOffset = -currentVisualOffset;
                    const normalizedOffset = (positiveOffset % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                    let targetSlotIndex;

                    // Desktop always snaps 'forward' visually on mouse out
                    targetSlotIndex = Math.ceil(normalizedOffset / layout.avatarSlotWidth);

                    let targetOffsetPositive = targetSlotIndex * layout.avatarSlotWidth;

                    // Handle loop wrap-around
                    if (targetOffsetPositive >= layout.scrollerLoopWidth) {
                        targetOffsetPositive = 0;
                    }

                    // Ensure it's within bounds (though should be handled by modulo above)
                    targetOffsetPositive = Math.max(0, targetOffsetPositive);
                    targetOffsetPositive = (targetOffsetPositive % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;

                    return -targetOffsetPositive; // Return the negative translateX value
                }


                /** Determines the index of the avatar item to hide during snap (Desktop only now). */
                function determineHiddenAvatarIndex(targetVisualOffset, direction) {
                    // No snapping/hiding logic needed on mobile
                    if (isMobileMode || layout.avatarSlotWidth <= 0 || renderedAvatarItems.length === 0) {
                        return -1;
                    }

                    const snappedSlotIndex = Math.round(Math.abs(targetVisualOffset) / layout.avatarSlotWidth);
                    let avatarToHideRawIndex;

                    // Desktop always snaps 'forward' visually
                    avatarToHideRawIndex = snappedSlotIndex + layout.visibleAvatarsCount;

                    const hiddenAvatarRenderedIndex = Math.floor(avatarToHideRawIndex) % renderedAvatarItems.length;
                    return (hiddenAvatarRenderedIndex + renderedAvatarItems.length) % renderedAvatarItems.length;
                }


                /** Desktop: Handles mouse entering the container. */
                function startHoverScroll() {
                    if (!isScrollingEnabled || isMobileMode) return; // Only run on desktop when enabled
                    isHovering = true;
                    hoverStartTime = performance.now();

                    // Ensure no avatars are hidden when hover starts
                    renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                    // Stop any potential snapping transition
                    scroller.classList.remove(SETTINGS.snappingClass);
                    scroller.removeEventListener('transitionend', onSnapTransitionEnd);

                    // Sync currentScrollPosition with visual state before starting animation
                    const currentVisualOffset = getCurrentTranslateX(scroller);
                    if (layout.scrollerLoopWidth > 0) {
                        const positiveOffset = (-currentVisualOffset + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                        currentScrollPosition = positiveOffset;
                    } else {
                        currentScrollPosition = -currentVisualOffset;
                    }

                    // Start the animation loop if not already running
                    if (!animationFrameId) {
                        animationFrameId = requestAnimationFrame(animateHoverScroll);
                    }
                }

                /** Initiates the snap-back animation (Desktop only now). */
                function snapScroller(direction) {
                    // --- MODIFICATION: Exit immediately if in mobile mode ---
                    if (!isScrollingEnabled || isMobileMode) return;
                    // --- END MODIFICATION ---

                    // Cancel any ongoing hover animation frame
                    if (animationFrameId && isHovering) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    // NOTE: We don't cancel mobile animationFrameId here as it's managed differently

                    const currentVisualOffset = getCurrentTranslateX(scroller);
                    const targetVisualOffset = calculateSnapTargetOffset(currentVisualOffset, direction); // direction is 'forward' for desktop

                    // --- Hiding Logic (Desktop Only) ---
                    // Check if already close to target - avoids unnecessary transition/flicker
                    if (Math.abs(currentVisualOffset - targetVisualOffset) < 0.5) {
                        // Apply final hidden state directly
                        const finalHiddenIndex = determineHiddenAvatarIndex(targetVisualOffset, direction);
                        renderedAvatarItems.forEach((item, index) => {
                            item.classList.toggle(SETTINGS.partiallyHiddenClass, index === finalHiddenIndex);
                        });
                        return; // No transition needed
                    }

                    // Determine which avatar to hide *before* starting the snap
                    const hiddenAvatarIndex = determineHiddenAvatarIndex(targetVisualOffset, direction);
                    renderedAvatarItems.forEach((item, index) => {
                        item.classList.toggle(SETTINGS.partiallyHiddenClass, index === hiddenAvatarIndex);
                    });
                    // --- End Hiding Logic ---


                    // Add class to enable CSS transition
                    scroller.classList.add(SETTINGS.snappingClass);
                    // Listen for transition end to clean up
                    scroller.addEventListener('transitionend', onSnapTransitionEnd, { once: true });

                    // Use rAF to ensure the class is applied before the transform changes
                    requestAnimationFrame(() => {
                        // Double check: only apply if still snapping and hover hasn't resumed
                        const stillSnapping = scroller.classList.contains(SETTINGS.snappingClass);
                        if (stillSnapping && !isHovering) {
                            scroller.style.transform = `translateX(${targetVisualOffset}px)`;
                            // Update logical scroll position to match the snapped state
                            if (layout.scrollerLoopWidth > 0) {
                                currentScrollPosition = (-targetVisualOffset + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                            } else {
                                currentScrollPosition = -targetVisualOffset;
                            }
                        } else if (isHovering) {
                            // If hover resumed during this rAF, cancel the snap immediately
                            scroller.classList.remove(SETTINGS.snappingClass);
                            scroller.removeEventListener('transitionend', onSnapTransitionEnd);
                            // Ensure hidden class is removed if snap cancelled
                            renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));
                        }
                    });
                }


                /** Desktop: Handles mouse leaving the container. */
                function stopHoverScrollAndSnap() {
                    // --- MODIFICATION: Exit immediately if in mobile mode ---
                    if (!isScrollingEnabled || isMobileMode) return;
                    // --- END MODIFICATION ---

                    isHovering = false;
                    hoverStartTime = null; // Reset hover start time
                    snapScroller('forward'); // Trigger the desktop snap
                }

                // --- Mobile Scroll Interaction ---

                /** Mobile: Handles the window scroll event. */
                function handlePageScroll() {
                    if (!isScrollingEnabled || !isMobileMode) return; // Only run on mobile when enabled

                    // --- MODIFICATION: Remove snap interruption logic ---
                    // Snapping doesn't happen on mobile scroll, so no need to interrupt it.
                    // if (scroller.classList.contains(SETTINGS.snappingClass)) {
                    //     scroller.classList.remove(SETTINGS.snappingClass);
                    //     scroller.removeEventListener('transitionend', onSnapTransitionEnd);
                    //     renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));
                    // }
                    // --- END MODIFICATION ---

                    // Clear any pending scroll stop timeout
                    if (scrollTimeoutId) clearTimeout(scrollTimeoutId);

                    const currentScrollY = window.scrollY;
                    const deltaY = currentScrollY - previousScrollY;

                    // Always scroll forward visually regardless of page scroll direction
                    currentScrollPosition += Math.abs(deltaY) * SETTINGS.scrollMultiplier;

                    // Ensure NO avatars are hidden during mobile scroll
                    renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                    scheduleScrollUpdate(); // Update visuals via rAF

                    previousScrollY = currentScrollY; // Store current scroll position for next event

                    // Set a timeout to detect when scrolling stops
                    scrollTimeoutId = setTimeout(handleScrollStop, SETTINGS.scrollStopDelay);
                }

                /** Mobile: Called when the scroll stop timeout completes. */
                function handleScrollStop() {
                    if (!isScrollingEnabled || !isMobileMode) return; // Only run on mobile when enabled
                    scrollTimeoutId = null; // Clear the timeout ID

                    // --- MODIFICATION: Remove the snapScroller call ---
                    // No snapping on mobile. The scroller stays where the last scroll update left it.
                    // snapScroller('forward'); // REMOVED
                    // --- END MODIFICATION ---

                    // Optionally, you could add logic here if needed when scroll stops on mobile,
                    // but snapping is explicitly removed.
                }


                // --- Initialization ---

                /** Sets up the avatar group component. */
                function initializeAvatarGroup() {
                    if (!SETTINGS.avatarUrls || SETTINGS.avatarUrls.length === 0) {
                        console.warn("No avatar URLs provided in SETTINGS.avatarUrls.");
                        if (countElement) countElement.style.display = 'none';
                        if (container) container.style.display = 'none';
                        return;
                    }

                    // Determine mode based on primary input mechanism
                    isMobileMode = window.matchMedia('(pointer: coarse)').matches;

                    // Use rAF to ensure layout calculations happen after potential CSS changes
                    requestAnimationFrame(() => {
                        // Read layout CSS variables
                        layout.avatarSize = getCssVariable('avatar-size', SETTINGS.cssVarDefaults.avatarSize);
                        layout.avatarOverlap = getCssVariable('avatar-overlap', SETTINGS.cssVarDefaults.avatarOverlap);
                        layout.visibleAvatarsCount = getCssVariable('visible-avatars', SETTINGS.cssVarDefaults.visibleAvatars);
                        layout.avatarSlotWidth = layout.avatarSize - layout.avatarOverlap;

                        // Set viewport width dynamically based on calculated values
                        if (viewport) {
                            const viewportWidth = layout.avatarSize + (layout.visibleAvatarsCount - 1) * layout.avatarSlotWidth;
                            // Use setProperty for CSS vars, but also set style directly for immediate effect
                            viewport.style.setProperty('--viewport-width', `${viewportWidth}px`);
                            viewport.style.width = `${viewportWidth}px`;
                        }

                        if (layout.avatarSlotWidth <= 0) {
                            console.error("Calculated 'avatarSlotWidth' is zero or negative. Disabling component.");
                            if (container) container.style.display = 'none';
                            return;
                        }

                        const totalUniqueAvatars = SETTINGS.avatarUrls.length;
                        isScrollingEnabled = totalUniqueAvatars >= SETTINGS.minAvatarsForScroll;

                        // Calculate loop width only if scrolling is enabled
                        if (isScrollingEnabled) {
                            layout.scrollerLoopWidth = layout.avatarSlotWidth * totalUniqueAvatars;
                        }

                        // Prepare and render avatars
                        const urlsToRender = prepareAvatarUrlsForRender(SETTINGS.avatarUrls);
                        populateAvatars(urlsToRender);

                        // Verify rendered items (fallback query if needed)
                        if (renderedAvatarItems.length === 0 && urlsToRender.length > 0) {
                            console.warn("Avatars populated but renderedAvatarItems empty. Re-querying.");
                            renderedAvatarItems = scroller.querySelectorAll(SETTINGS.avatarItemSelector);
                        }

                        if (isScrollingEnabled) {
                            // Configure count display
                            if (SETTINGS.staticCountText && countElement) {
                                countElement.textContent = SETTINGS.staticCountText;
                                countElement.style.display = ''; // Make sure it's visible
                            } else if (countElement) {
                                countElement.style.display = 'none'; // Hide if no text provided
                            }

                            // Initial state and event listeners based on mode
                            if (isMobileMode) {
                                // Mobile setup: scroll-driven, no initial hiding, no hover events
                                previousScrollY = window.scrollY; // Initialize scroll position tracking
                                document.addEventListener('scroll', handlePageScroll, { passive: true });
                                // Ensure hover listeners are removed if they somehow existed
                                if (container) {
                                    container.removeEventListener('mouseenter', startHoverScroll);
                                    container.removeEventListener('mouseleave', stopHoverScrollAndSnap);
                                }
                                // Ensure NO avatars are hidden initially on mobile
                                renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                            } else {
                                // Desktop setup: hover-driven, initial hide, add hover listeners
                                if (container) {
                                    container.addEventListener('mouseenter', startHoverScroll);
                                    container.addEventListener('mouseleave', stopHoverScrollAndSnap);
                                }
                                // Remove scroll listener if it somehow existed
                                document.removeEventListener('scroll', handlePageScroll);

                                // Desktop: Hide the avatar just outside the viewport initially
                                const initialHiddenIndex = Math.floor(layout.visibleAvatarsCount) % renderedAvatarItems.length;
                                if (renderedAvatarItems.length > initialHiddenIndex && renderedAvatarItems[initialHiddenIndex]) {
                                    // Ensure others are visible first
                                    renderedAvatarItems.forEach((item, index) => {
                                        item.classList.toggle(SETTINGS.partiallyHiddenClass, index === initialHiddenIndex);
                                    });
                                } else if (renderedAvatarItems.length <= layout.visibleAvatarsCount) {
                                    // If not enough avatars to hide one, ensure count is also hidden
                                    if (countElement) countElement.style.display = 'none';
                                    console.warn("Fewer rendered avatars than visible slots + 1. Hiding count.");
                                }
                            }

                        } else {
                            // Scrolling disabled (not enough avatars):
                            // Hide count, adjust width to fit visible avatars without overlap beyond the last one
                            if (countElement) countElement.style.display = 'none';
                            const nonScrollingAvatarCount = Math.min(totalUniqueAvatars, layout.visibleAvatarsCount);
                            const nonScrollingWidth = layout.avatarSize + Math.max(0, nonScrollingAvatarCount - 1) * layout.avatarSlotWidth;
                            if (viewport) viewport.style.width = `${nonScrollingWidth}px`;
                            // Ensure no avatars are hidden if scrolling is off
                            renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));
                        }

                        // Reset initial visual state
                        if (scroller) scroller.style.transform = 'translateX(0px)';
                        currentScrollPosition = 0; // Reset logical position
                    });
                }

                // --- Run Initialization ---
                // Initialize on DOM ready
                document.addEventListener('DOMContentLoaded', initializeAvatarGroup);

                // Optional: Re-initialize on resize or orientation change if needed,
                // especially if CSS variables change significantly with breakpoints.
                // Consider debouncing this for performance.
                // window.addEventListener('resize', debounce(initializeAvatarGroup, 250));

            })(); // End of IIFE
        </script>

    </body>

</html>