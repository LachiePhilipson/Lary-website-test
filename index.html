<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Avatar Group</title>
        <!-- Import IBM Plex Sans font -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@700&display=swap" rel="stylesheet">

        <style>
            /* --- General Page Style --- */
            body {
                background-color: #260A2F;
                min-height: 100vh;
                padding: 60px 20px;
                box-sizing: border-box;
                font-family: 'IBM Plex Sans', sans-serif;
                margin: 0;
                color: #FFFFFF;
                display: flex;
                flex-direction: column;
            }

            /* --- Hero Content Styling --- */
            .hero-content {
                font-size: 4rem;
                font-weight: bold;
                line-height: 1.2;
                letter-spacing: -0.02em;
                text-align: left;
                max-width: 1200px;
                width: 100%;
                /* --- START Modifications for 50vh Height & Centering --- */
                height: 50vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                margin-left: auto;
                margin-right: auto;
                flex-shrink: 0;
                /* --- END Modifications --- */
            }

            .hero-content .line-1 {
                display: flex;
                align-items: baseline;
                flex-wrap: wrap;
                margin-bottom: 0.1em;
            }

            .hero-content .line-2,
            .hero-content .line-3,
            .hero-content .line-4 {
                margin-bottom: 0.1em;
                word-break: break-word;
            }

            .hero-content .inline-block {
                display: inline-block;
                vertical-align: middle;
                margin: 0 0.2em;
                position: relative;
                line-height: 1;
            }

            .hero-content .spark-svg {
                display: inline-block;
                vertical-align: baseline;
                width: 0.8em;
                height: 0.8em;
                margin: 0 0.05em;
                position: relative;
                top: -0.05em;
            }

            .hero-content .text-orange {
                color: #FF4F00;
            }

            /* --- Scrollable Content Styling --- */
            .scrollable-content {
                flex-grow: 1;
                overflow-y: auto;
                max-width: 1200px;
                width: 100%;
                margin-left: auto;
                margin-right: auto;
                padding-top: 2em;
            }

            .scrollable-content p {
                font-family: sans-serif;
                font-weight: normal;
                font-size: 1rem;
                line-height: 1.7;
                margin-bottom: 1.5em;
                color: #fff;
            }

            .scrollable-content h2 {
                margin-top: 2em;
                margin-bottom: 1em;
            }


            /* --- Avatar Group Styling --- */
            :root {
                /* Core Dimensions & Layout */
                --avatar-size: 72px;
                --avatar-overlap: 20px;
                --visible-avatars: 3;
                --container-padding: 0px;

                /* Border & Background Settings */
                --background-color-outer: #FF4F00;
                --border-color-outer: #FFE0CC;
                --border-width-outer: 4px;
                --background-color-inner: #FF4F00;
                --avatar-stroke-color: #FF4F00;
                --avatar-border-thickness: 6px;
                --viewport-overlay-border-width: 6px;
                --viewport-overlay-border-color: #FF4F00;

                /* Concentric Border Radii */
                --border-radius-outer: 20px;
                --border-radius-viewport: max(0px, calc(var(--border-radius-outer) - var(--border-width-outer) - var(--container-padding)));
                --border-radius-avatar-item: max(0px, var(--border-radius-viewport));
                --border-radius-avatar-image: max(0px, calc(var(--border-radius-avatar-item) - var(--avatar-border-thickness)));

                /* Derived Layout Calculations */
                --avatar-slot-width: calc(var(--avatar-size) - var(--avatar-overlap));
                /* --viewport-width is now set dynamically by JS */

                /* Plus Count Appearance */
                --text-color-count: #FFFFFF;
                --font-size-count: 26px;
                --count-margin-left: 10px;
            }

            .avatar-group-container {
                display: flex;
                align-items: center;
                padding: var(--container-padding);
                background-color: var(--background-color-outer);
                border-radius: var(--border-radius-outer);
                border: var(--border-width-outer) solid var(--border-color-outer);
                width: fit-content;
                cursor: default;
                box-sizing: border-box;
                overflow: hidden;
                position: relative;
            }

            .avatar-viewport {
                width: var(--viewport-width);
                /* Dynamically set via JS */
                height: var(--avatar-size);
                overflow: hidden;
                border-radius: var(--border-radius-viewport);
                position: relative;
                box-sizing: border-box;
            }

            .avatar-viewport::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                border-radius: inherit;
                border: var(--viewport-overlay-border-width) solid var(--viewport-overlay-border-color);
                box-sizing: border-box;
                pointer-events: none;
                z-index: 10;
            }

            .avatar-scroller {
                display: flex;
                height: 100%;
                will-change: transform;
                box-sizing: border-box;
                position: relative;
                transform: translateX(0);
            }

            .avatar-scroller.snapping {
                transition: transform 0.5s cubic-bezier(0.66, 0.8, 0.66, 1);
            }

            .avatar-item {
                width: var(--avatar-size);
                height: var(--avatar-size);
                flex-shrink: 0;
                margin-right: calc(-1 * var(--avatar-overlap));
                border-radius: var(--border-radius-avatar-item);
                overflow: hidden;
                background-color: var(--background-color-inner);
                box-sizing: border-box;
                display: flex;
                justify-content: center;
                align-items: center;
                border: var(--avatar-border-thickness) solid var(--avatar-stroke-color);
                position: relative;
                opacity: 1;
                transition: transform 0.5s;
                /* Opacity transition handled separately for snap */
                pointer-events: auto;
            }

            .avatar-item.is-partially-hidden {
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease-in-out;
                /* Add transition for hiding */
            }

            /* Make visible smoothly */
            .avatar-item:not(.is-partially-hidden) {
                opacity: 1;
                transition: opacity 0.3s ease-in-out 0.1s;
                /* Delay becoming visible slightly */
            }


            .avatar-item img {
                display: block;
                width: 100%;
                height: 100%;
                object-fit: cover;
                object-position: center center;
                border-radius: var(--border-radius-avatar-image);
                overflow: hidden;
            }

            .avatar-plus-count {
                color: var(--text-color-count);
                font-size: var(--font-size-count);
                font-weight: 700;
                margin-left: var(--count-margin-left);
                margin-right: 16px;
                white-space: nowrap;
                pointer-events: none;
                user-select: none;
                box-sizing: border-box;
                z-index: 50;
            }

            /* --- End Avatar Group Styling --- */

            /* --- Responsive Adjustments --- */
            @media (max-width: 768px) {
                body {
                    padding: 40px 15px;
                }

                .hero-content {
                    font-size: 2.5rem;
                    height: auto;
                    min-height: 40vh;
                    padding: 2em 0;
                }

                .hero-content .inline-block {
                    margin: 0.2em 0.15em;
                    margin-bottom: 0.4em;
                }

                .scrollable-content {
                    padding-top: 1.5em;
                }

                /* Optional: Adjust avatar size on mobile */
                /* :root {
                    --avatar-size: 60px;
                    --avatar-overlap: 15px;
                    --font-size-count: 22px;
                } */
            }

            @media (max-width: 480px) {
                body {
                    padding: 30px 10px;
                }

                .hero-content {
                    font-size: 2rem;
                    min-height: 35vh;
                    padding: 1.5em 0;
                }

                :root {
                    --avatar-size: 56px;
                    --avatar-overlap: 15px;
                    --font-size-count: 20px;
                    --border-radius-outer: 16px;
                    --avatar-border-thickness: 4px;
                    --viewport-overlay-border-width: 4px;
                }

                .avatar-plus-count {
                    margin-right: 10px;
                }

                .scrollable-content {
                    padding-top: 1em;
                }

                .scrollable-content p {
                    font-size: 0.95rem;
                }
            }
        </style>
    </head>

    <body>
        <div class="hero-content">
            <div class="line-1">
                <span>Wir</span>
                <div class="inline-block">
                    <!-- Avatar Group Component -->
                    <div class="avatar-group-container" id="interactiveAvatarGroup">
                        <div class="avatar-viewport">
                            <div class="avatar-scroller">
                                <!-- Avatars dynamically added here -->
                            </div>
                        </div>
                        <div class="avatar-plus-count" id="avatarCount">+25</div>
                    </div>
                    <!-- End Avatar Group Component -->
                </div>
                <span>verwandeln</span>
            </div>
            <div class="line-2">
                <span>deine</span>
                <svg class="spark-svg" viewBox="0 0 57 56" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd"
                          d="M0.919922 26.8242C14.0381 23.4473 24.3672 13.1159 27.7441 0H30.0957C33.4727 13.1159 43.8018 23.4473 56.9199 26.8242V29.1758C43.8018 32.5527 33.4727 42.8841 30.0957 56H27.7441C24.3672 42.8796 14.0392 32.5527 0.919922 29.1758V26.8242Z"
                          fill="#FF4F00" />
                </svg>
                <span class="text-orange">komplexen</span>
            </div>
            <div class="line-3">
                <span class="text-orange">Herausforderungen</span> <span>in</span>
            </div>
            <div class="line-4">
                <span>digitale Lösungen</span>
            </div>
        </div>

        <div class="scrollable-content">
            <!-- Placeholder text -->
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>
            <p>Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam varius, turpis et commodo pharetra, est eros bibendum
                elit, nec luctus magna felis sollicitudin mauris. Integer in mauris eu nibh euismod gravida.</p>
            <p>Duis ac tellus et risus vulputate vehicula. Donec lobortis risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue, eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas fermentum consequat mi. Donec
                fermentum. Pellentesque malesuada nulla a mi.</p>
            <p>Duis sapien sem, aliquet nec, commodo eget, consequat quis, neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque nunc. Nullam arcu. Aliquam erat
                volutpat. Duis ac turpis. Integer rutrum ante eu lacus.</p>
            <p>Ut cursus et vel nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Mauris pretium lacus et magna. Fusce quis neque vel lectus ultricies suscipit. Sed feugiat. Fusce ut diam. Integer egestas,
                orci quis laoreet dapibus, magna dolor pharetra magna, eu iaculis justo odio quis arcu.</p>
            <p>Nam sed tellus id magna elementum tincidunt. Morbi tincidunt, dui sit amet facilisis feugiat, odio metus gravida ante, ut pharetra massa metus id nunc. Pellentesque scelerisque. Nunc sit amet velit. Integer imperdiet turpis nec elit.
                Proin nec justo. Vivamus luctus, ipsum id venenatis consectetuer, velit augue luctus metus, ac sagittis neque orci sit amet odio.</p>
            <p>Sed sagittis, leo et facilisis lobortis, sapien nibh tempor elit, non eleifend enim magna non nisl. Nullam eleifend placerat lacus. Quisque facilisis suscipit elit. Pellentesque habitant morbi tristique senectus et netus et malesuada
                fames ac turpis egestas. Morbi lectus. Nulla facilisi.</p>
            <p>Vestibulum et metus. Curabitur et felis. Praesent sagittis. Sed aliquet odio vitae tortor. Nunc tincidunt nisi vitae velit. Aliquam erat volutpat. Integer malesuada. Class aptent taciti sociosqu ad litora torquent per conubia nostra,
                per inceptos himenaeos.</p>
        </div>

        <script>
            (function () { // IIFE for encapsulation
                'use strict';

                // --- Configuration & Settings ---
                const SETTINGS = {
                    containerId: 'interactiveAvatarGroup',
                    viewportSelector: '.avatar-viewport',
                    scrollerSelector: '.avatar-scroller',
                    countSelector: '#avatarCount',
                    avatarItemSelector: '.avatar-item',
                    avatarUrls: [ // Avatars will appear in this specific order
                        'https://picsum.photos/id/10/150/150',
                        'https://picsum.photos/id/20/150/150',
                        'https://picsum.photos/id/30/150/150',
                        'https://picsum.photos/id/40/150/150',
                        'https://picsum.photos/id/50/150/150',
                        'https://picsum.photos/id/60/150/150'
                        // Add more URLs here as needed
                    ],
                    staticCountText: "+25", // Text for the count element when scrolling is active. Set to null/empty to hide.
                    scrollSpeedFactor: 0.15, // Desktop: Multiplier for hover scroll speed. Adjust for feel.
                    easeInDurationMs: 1500, // Desktop: Duration of the ease-in effect on hover start (milliseconds).
                    minAvatarsForScroll: 4, // Minimum total avatars needed to enable scrolling behavior.
                    scrollMultiplier: 0.8, // Mobile: How much avatar scrolls per pixel of page scroll. Adjust for feel.
                    cssVarDefaults: { // Fallback values if CSS variables are not readable
                        avatarSize: 72,
                        avatarOverlap: 20,
                        visibleAvatars: 3
                    },
                    // CSS classes used for state management
                    snappingClass: 'snapping',
                    partiallyHiddenClass: 'is-partially-hidden'
                };

                // --- DOM Element References ---
                const container = document.getElementById(SETTINGS.containerId);
                if (!container) {
                    console.error(`Avatar group container with ID "${SETTINGS.containerId}" not found.`);
                    return;
                }
                const viewport = container.querySelector(SETTINGS.viewportSelector);
                const scroller = container.querySelector(SETTINGS.scrollerSelector);
                const countElement = container.querySelector(SETTINGS.countSelector);

                if (!viewport || !scroller || !countElement) {
                    console.error("Required elements (viewport, scroller, count) not found within the container.");
                    return;
                }

                // --- State Variables ---
                let isHovering = false; // Desktop: Is the mouse currently over the container?
                let isScrollingEnabled = false; // Is the interactive behavior active?
                let isMobileMode = false; // Is the scroll-driven behavior active?
                let animationFrameId = null; // ID for cancelling the animation frame loop (hover/scroll update)
                let hoverStartTime = null; // Desktop: Timestamp when hover began (for easing)
                let currentScrollPosition = 0; // Tracks the logical scroll position (can exceed loop width, can be negative)
                let renderedAvatarItems = []; // NodeList of all rendered avatar DOM elements
                let layout = { // Stores calculated layout values
                    avatarSize: 0,
                    avatarOverlap: 0,
                    visibleAvatarsCount: 0,
                    avatarSlotWidth: 0, // Effective width each avatar occupies (size - overlap)
                    scrollerLoopWidth: 0 // Width of one full cycle of unique avatars (unique count * slot width)
                };
                // --- State for Mobile Scroll ---
                let previousScrollY = 0; // Mobile: Stores previous window scroll position
                let isScrollUpdatePending = false; // Mobile: Flag for rAF scroll update throttling

                // --- Utility Functions ---

                /** Reads a CSS custom property value from the root element */
                function getCssVariable(varName, defaultValue) {
                    const value = getComputedStyle(document.documentElement).getPropertyValue(`--${varName}`).trim();
                    const parsedValue = parseInt(value, 10);
                    return !isNaN(parsedValue) ? parsedValue : defaultValue;
                }

                /** Gets the current horizontal translation (translateX) from element style or computed style */
                function getCurrentTranslateX(element) {
                    try {
                        const styleTransform = element.style.transform;
                        if (styleTransform && styleTransform.includes('translateX')) {
                            const match = styleTransform.match(/translateX\(([-.\d]+)px\)/);
                            if (match && match[1]) {
                                return parseFloat(match[1]);
                            }
                        }
                        const computedTransform = window.getComputedStyle(element).transform;
                        if (computedTransform && computedTransform !== 'none') {
                            const matrix = new DOMMatrixReadOnly(computedTransform);
                            return matrix.m41; // m41 corresponds to the tx value in a 2D matrix
                        }
                    } catch (e) {
                        console.warn("Could not parse transform matrix:", e);
                    }
                    return 0; // Default to 0 if unable to parse
                }

                /** Creates and appends avatar elements to the scroller */
                function populateAvatars(urls) {
                    const fragment = document.createDocumentFragment();
                    urls.forEach(url => {
                        const item = document.createElement('div');
                        item.className = SETTINGS.avatarItemSelector.substring(1); // Remove leading '.'
                        const img = document.createElement('img');
                        img.src = url;
                        img.alt = 'Team Member Avatar'; // Consider more descriptive alt text if possible
                        img.loading = 'lazy'; // Improve initial page load performance
                        img.draggable = false; // Prevent default image drag behavior
                        item.appendChild(img);
                        fragment.appendChild(item);
                    });
                    scroller.appendChild(fragment);
                    // Update the reference to the newly added DOM elements
                    renderedAvatarItems = scroller.querySelectorAll(SETTINGS.avatarItemSelector);
                }

                /**
                 * Prepares avatar URLs for rendering by duplicating and prepending
                 * the original sequence as needed for seamless looping, maintaining the original order.
                 */
                function prepareAvatarUrlsForRender(uniqueUrls) {
                    const totalUniqueAvatars = uniqueUrls.length;
                    let urlsToRender = [...uniqueUrls]; // Start with the original, ordered list

                    if (isScrollingEnabled) {
                        // Calculate how many avatars are needed for seamless looping in both directions.
                        // Need visible count + one full set for forward wrap + one full set for backward wrap.
                        const requiredCount = layout.visibleAvatarsCount + totalUniqueAvatars * 2;

                        // Duplicate the original sequence until we have enough avatars.
                        // Using a safety counter to prevent potential infinite loops with unusual settings.
                        let safetyCounter = 0;
                        const maxSafetyCount = 15;
                        while (urlsToRender.length < requiredCount && safetyCounter < maxSafetyCount) {
                            urlsToRender.push(...uniqueUrls); // Append the original ordered sequence
                            safetyCounter++;
                        }
                        if (safetyCounter >= maxSafetyCount) {
                            console.warn("Avatar duplication limit reached. Looping might not be seamless.");
                        }

                        // Prepend one full original sequence to allow immediate backward scrolling/wrapping.
                        urlsToRender = [...uniqueUrls, ...urlsToRender];
                    }
                    return urlsToRender;
                }


                // --- Animation & Interaction Logic ---

                /** Easing function (Ease-Out Cubic) for desktop hover acceleration */
                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                /** Desktop: Animation loop callback for hover scrolling. */
                function animateHoverScroll() {
                    if (!isHovering || !isScrollingEnabled || isMobileMode) {
                        animationFrameId = null; // Stop the loop if conditions aren't met
                        return;
                    }
                    const currentTime = performance.now();
                    // Calculate time elapsed since hover started for easing effect
                    const elapsedTime = currentTime - (hoverStartTime || currentTime);
                    // Apply easing function (progress capped at 1)
                    const easeProgress = Math.min(1, elapsedTime / SETTINGS.easeInDurationMs);
                    const easedFactor = easeOutCubic(easeProgress);
                    // Calculate current scroll speed based on settings and easing
                    const currentSpeed = (layout.avatarSlotWidth * SETTINGS.scrollSpeedFactor) * easedFactor;

                    currentScrollPosition += currentSpeed; // Increment logical scroll position (always forward on hover)

                    applyScrollPosition(); // Update the visual translateX

                    // Request the next frame to continue the animation
                    animationFrameId = requestAnimationFrame(animateHoverScroll);
                }

                /** Mobile: Callback for the rAF used to update scroll position based on page scroll */
                function performScrollUpdate() {
                    if (!isScrollUpdatePending) return; // Exit if no update is scheduled

                    // Apply the calculated visual offset
                    applyScrollPosition();

                    isScrollUpdatePending = false; // Reset the flag
                    animationFrameId = null; // Release the rAF lock
                }

                /** Mobile: Schedules a scroll update using requestAnimationFrame for performance */
                function scheduleScrollUpdate() {
                    isScrollUpdatePending = true; // Mark that an update is needed
                    if (!animationFrameId) { // Only request a new frame if one isn't already pending
                        animationFrameId = requestAnimationFrame(performScrollUpdate);
                    }
                }

                /** Common function to apply the currentScrollPosition visually using translateX, handling wrapping */
                function applyScrollPosition() {
                    let visualOffset = 0;
                    if (layout.scrollerLoopWidth > 0) {
                        // Use modulo arithmetic to wrap the scroll position within the loop width.
                        // Ensures the visual offset stays within [0, scrollerLoopWidth).
                        // The double modulo handles potential negative results from JS '%' operator.
                        visualOffset = (currentScrollPosition % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                    } else {
                        // If no looping (scrolling disabled or error), just use the raw position.
                        visualOffset = currentScrollPosition;
                    }
                    scroller.style.transform = `translateX(-${visualOffset}px)`;
                }


                /** Desktop: Callback function for when the snap transition ends. */
                function onSnapTransitionEnd() {
                    scroller.classList.remove(SETTINGS.snappingClass);
                    scroller.removeEventListener('transitionend', onSnapTransitionEnd);

                    // Ensure visual position matches logical position after snap
                    applyScrollPosition();

                    // Re-calculate which avatar should be hidden based on the final snapped position.
                    const finalVisualOffset = getCurrentTranslateX(scroller);
                    const finalHiddenIndex = determineHiddenAvatarIndex(finalVisualOffset);
                    renderedAvatarItems.forEach((item, index) => {
                        item.classList.toggle(SETTINGS.partiallyHiddenClass, index === finalHiddenIndex);
                    });
                }

                /** Desktop: Calculates the target scroll offset for snapping back on mouse leave. */
                function calculateSnapTargetOffset(currentVisualOffset) {
                    // Snapping is only for desktop mode with looping enabled.
                    if (isMobileMode || layout.scrollerLoopWidth <= 0 || layout.avatarSlotWidth <= 0) {
                        return currentVisualOffset; // Return current offset if no snap needed
                    }

                    // Normalize the current offset to be positive and within the loop width.
                    const positiveOffset = (-currentVisualOffset % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;

                    // Find the index of the next slot to snap to (always rounding up for forward snap).
                    const targetSlotIndex = Math.ceil(positiveOffset / layout.avatarSlotWidth);

                    // Calculate the target offset in the positive range [0, scrollerLoopWidth).
                    let targetOffsetPositive = (targetSlotIndex * layout.avatarSlotWidth) % layout.scrollerLoopWidth;

                    // Return the negative value required for translateX.
                    return -targetOffsetPositive;
                }


                /** Desktop: Determines the index of the avatar item to hide during/after snap animation. */
                function determineHiddenAvatarIndex(targetVisualOffset) {
                    // Hiding logic is only for desktop mode with looping enabled.
                    if (isMobileMode || layout.avatarSlotWidth <= 0 || renderedAvatarItems.length === 0) {
                        return -1; // Return -1 if no avatar should be hidden
                    }

                    // Calculate the slot index corresponding to the target visual offset.
                    // Use Math.round as snapping might end slightly off the exact slot boundary.
                    const snappedSlotIndex = Math.round(Math.abs(targetVisualOffset) / layout.avatarSlotWidth);

                    // The avatar to hide is the one that will become the first fully visible one *after* the snap.
                    // This corresponds to the snappedSlotIndex plus the number of visible avatars.
                    const avatarToHideRawIndex = snappedSlotIndex + layout.visibleAvatarsCount;

                    // Wrap the index using modulo to handle looping correctly.
                    const hiddenAvatarRenderedIndex = avatarToHideRawIndex % renderedAvatarItems.length;

                    // Ensure the index is positive (though modulo should handle this if operands are positive).
                    return (hiddenAvatarRenderedIndex + renderedAvatarItems.length) % renderedAvatarItems.length;
                }


                /** Desktop: Handles mouse entering the container. Starts hover animation. */
                function startHoverScroll() {
                    if (!isScrollingEnabled || isMobileMode) return; // Only run on desktop when enabled

                    isHovering = true;
                    hoverStartTime = performance.now(); // Record start time for easing

                    // Make all avatars visible when hover starts for smooth transition
                    renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                    // Stop any ongoing snap transition immediately
                    scroller.classList.remove(SETTINGS.snappingClass);
                    scroller.removeEventListener('transitionend', onSnapTransitionEnd);

                    // Sync logical scroll position with the current visual state before starting animation
                    const currentVisualOffset = getCurrentTranslateX(scroller);
                    if (layout.scrollerLoopWidth > 0) {
                        // Normalize visual offset to positive value within loop width
                        const positiveOffset = (-currentVisualOffset % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                        currentScrollPosition = positiveOffset;
                    } else {
                        currentScrollPosition = -currentVisualOffset; // Use raw offset if no loop
                    }

                    // Start the animation loop if not already running
                    if (!animationFrameId) {
                        animationFrameId = requestAnimationFrame(animateHoverScroll);
                    }
                }

                /** Desktop: Initiates the snap-back animation on mouse leave. */
                function snapScroller() {
                    if (!isScrollingEnabled || isMobileMode) return; // Only run on desktop when enabled

                    // Cancel any ongoing hover animation frame
                    if (animationFrameId && isHovering) { // Check isHovering in case leave event fires erratically
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    const currentVisualOffset = getCurrentTranslateX(scroller);
                    const targetVisualOffset = calculateSnapTargetOffset(currentVisualOffset);

                    // --- Hiding Logic for Snap (Desktop Only) ---
                    if (layout.avatarSlotWidth <= 0) return; // Prevent errors if layout is invalid

                    const hiddenAvatarIndex = determineHiddenAvatarIndex(targetVisualOffset);

                    // Check if already very close to the target (avoids unnecessary transition/flicker)
                    if (Math.abs(currentVisualOffset - targetVisualOffset) < 0.5) {
                        renderedAvatarItems.forEach((item, index) => {
                            // Ensure final hidden state is correct even if no transition occurs
                            item.classList.toggle(SETTINGS.partiallyHiddenClass, index === hiddenAvatarIndex);
                        });
                        // Sync logical position just in case
                        currentScrollPosition = Math.abs(targetVisualOffset);
                        return; // No transition needed
                    }

                    // Apply the hidden class *before* starting the transition for a smoother effect
                    renderedAvatarItems.forEach((item, index) => {
                        item.classList.toggle(SETTINGS.partiallyHiddenClass, index === hiddenAvatarIndex);
                    });
                    // --- End Hiding Logic ---

                    // Add class to enable CSS transition for snapping
                    scroller.classList.add(SETTINGS.snappingClass);
                    // Listen for transition end to clean up classes and state
                    scroller.addEventListener('transitionend', onSnapTransitionEnd, { once: true });

                    // Use rAF to ensure the style change happens *after* the class is applied
                    requestAnimationFrame(() => {
                        // Double check: only apply transform if still snapping and hover hasn't immediately resumed
                        const stillSnapping = scroller.classList.contains(SETTINGS.snappingClass);
                        if (stillSnapping && !isHovering) {
                            scroller.style.transform = `translateX(${targetVisualOffset}px)`;
                            // Update logical scroll position to match the snapped visual state
                            if (layout.scrollerLoopWidth > 0) {
                                currentScrollPosition = (-targetVisualOffset % layout.scrollerLoopWidth + layout.scrollerLoopWidth) % layout.scrollerLoopWidth;
                            } else {
                                currentScrollPosition = -targetVisualOffset;
                            }
                        } else if (isHovering) {
                            // If hover resumed extremely quickly (during this rAF), cancel the snap
                            scroller.classList.remove(SETTINGS.snappingClass);
                            scroller.removeEventListener('transitionend', onSnapTransitionEnd);
                            // Ensure hidden class is removed if snap was cancelled mid-flight
                            renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));
                        }
                    });
                }


                /** Desktop: Handles mouse leaving the container. Stops hover and starts snap. */
                function stopHoverScrollAndSnap() {
                    if (!isScrollingEnabled || isMobileMode) return; // Only run on desktop when enabled

                    isHovering = false;
                    hoverStartTime = null; // Reset hover start time

                    snapScroller(); // Trigger the snap-back animation
                }

                // --- Mobile Scroll Interaction ---

                /** Mobile: Handles the window scroll event to drive avatar scrolling. */
                function handlePageScroll() {
                    if (!isScrollingEnabled || !isMobileMode) return; // Only run on mobile when enabled

                    const currentScrollY = window.scrollY;
                    const deltaY = currentScrollY - previousScrollY; // Calculate change in page scroll

                    // Update logical scroll position based on page scroll direction and multiplier
                    // Scrolling DOWN (deltaY > 0) moves avatars FORWARD (increases position)
                    // Scrolling UP   (deltaY < 0) moves avatars BACKWARD (decreases position)
                    currentScrollPosition += deltaY * SETTINGS.scrollMultiplier;

                    // Ensure NO avatars are hidden during mobile scroll interaction
                    renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                    scheduleScrollUpdate(); // Schedule visual update via rAF

                    previousScrollY = currentScrollY; // Store current scroll position for the next event
                }


                // --- Initialization ---

                /** Sets up the avatar group component, calculates layout, populates avatars, and adds event listeners. */
                function initializeAvatarGroup() {
                    if (!SETTINGS.avatarUrls || SETTINGS.avatarUrls.length === 0) {
                        console.warn("No avatar URLs provided in SETTINGS.avatarUrls. Hiding component.");
                        if (countElement) countElement.style.display = 'none';
                        if (container) container.style.display = 'none';
                        return;
                    }

                    // Determine interaction mode based on primary input mechanism (touch vs mouse)
                    // This is a decent proxy for mobile vs desktop, but not perfect.
                    isMobileMode = window.matchMedia('(pointer: coarse)').matches;

                    // Use rAF to ensure layout calculations happen after any potential CSS reflows/updates
                    requestAnimationFrame(() => {
                        // Clear previous state if re-initializing (e.g., on resize)
                        if (scroller) scroller.innerHTML = '';
                        renderedAvatarItems = [];
                        currentScrollPosition = 0;
                        isHovering = false;
                        hoverStartTime = null;
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                        scroller.classList.remove(SETTINGS.snappingClass); // Remove transition class
                        scroller.removeEventListener('transitionend', onSnapTransitionEnd); // Remove listener

                        // Read layout-related CSS variables with fallbacks
                        layout.avatarSize = getCssVariable('avatar-size', SETTINGS.cssVarDefaults.avatarSize);
                        layout.avatarOverlap = getCssVariable('avatar-overlap', SETTINGS.cssVarDefaults.avatarOverlap);
                        layout.visibleAvatarsCount = getCssVariable('visible-avatars', SETTINGS.cssVarDefaults.visibleAvatars);
                        layout.avatarSlotWidth = layout.avatarSize - layout.avatarOverlap;

                        // Set the viewport width dynamically based on calculated values
                        if (viewport) {
                            // Calculate width needed to show the specified number of visible avatars perfectly
                            const viewportWidth = layout.avatarSize + (layout.visibleAvatarsCount - 1) * layout.avatarSlotWidth;
                            // Set both the CSS variable (if used elsewhere) and the direct style
                            viewport.style.setProperty('--viewport-width', `${viewportWidth}px`);
                            viewport.style.width = `${viewportWidth}px`;
                        }

                        // Basic validation: Ensure avatars have a positive effective width
                        if (layout.avatarSlotWidth <= 0) {
                            console.error("Calculated 'avatarSlotWidth' is zero or negative (check --avatar-size and --avatar-overlap). Disabling component.");
                            if (container) container.style.display = 'none';
                            return;
                        }

                        const totalUniqueAvatars = SETTINGS.avatarUrls.length;
                        // Determine if scrolling behavior should be enabled
                        isScrollingEnabled = totalUniqueAvatars >= SETTINGS.minAvatarsForScroll;

                        // Calculate the width of one full loop of unique avatars (only if scrolling is enabled)
                        layout.scrollerLoopWidth = isScrollingEnabled ? layout.avatarSlotWidth * totalUniqueAvatars : 0;

                        // Prepare the final list of URLs to render (handles duplication/prepending for looping)
                        const urlsToRender = prepareAvatarUrlsForRender(SETTINGS.avatarUrls);
                        populateAvatars(urlsToRender); // Create and append avatar elements

                        // Verify that avatars were actually added to the DOM
                        if (renderedAvatarItems.length === 0 && urlsToRender.length > 0) {
                            console.warn("Avatars populated but renderedAvatarItems query returned empty. Check selectors/timing.");
                            // Attempt re-query as a fallback (though populateAvatars should handle this)
                            renderedAvatarItems = scroller.querySelectorAll(SETTINGS.avatarItemSelector);
                        }


                        // --- Initial Offset and State ---
                        let initialOffset = 0;
                        // For mobile mode with scrolling enabled, start scrolled forward by one loop width.
                        // This allows the user to immediately scroll UP (backward) without hitting the start.
                        if (isMobileMode && isScrollingEnabled && layout.scrollerLoopWidth > 0) {
                            initialOffset = layout.scrollerLoopWidth;
                            currentScrollPosition = initialOffset; // Set logical position
                        }
                        // Apply the initial visual state (translateX)
                        if (scroller) scroller.style.transform = `translateX(-${initialOffset}px)`;
                        // --- End Initial Offset ---


                        // --- Setup based on whether scrolling is enabled ---
                        if (isScrollingEnabled) {
                            // Configure count display visibility and text
                            if (SETTINGS.staticCountText && countElement) {
                                countElement.textContent = SETTINGS.staticCountText;
                                countElement.style.display = ''; // Ensure visible
                            } else if (countElement) {
                                countElement.style.display = 'none'; // Hide if no text provided
                            }

                            // Clean up any existing listeners before adding new ones (important for re-init)
                            document.removeEventListener('scroll', handlePageScroll);
                            if (container) {
                                container.removeEventListener('mouseenter', startHoverScroll);
                                container.removeEventListener('mouseleave', stopHoverScrollAndSnap);
                            }

                            // Add event listeners based on the determined mode (mobile vs desktop)
                            if (isMobileMode) {
                                // Mobile: Listen for page scroll
                                previousScrollY = window.scrollY; // Initialize scroll position tracking
                                document.addEventListener('scroll', handlePageScroll, { passive: true });
                                // Ensure NO avatars are hidden initially on mobile
                                renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));
                            } else {
                                // Desktop: Listen for mouse hover events
                                if (container) {
                                    container.addEventListener('mouseenter', startHoverScroll);
                                    container.addEventListener('mouseleave', stopHoverScrollAndSnap);
                                }
                                // Desktop: Initially hide the avatar that's just outside the viewport on the right.
                                if (layout.avatarSlotWidth > 0) { // Check layout validity
                                    // Calculate index based on the initial visual offset
                                    const initialHiddenIndex = determineHiddenAvatarIndex(-initialOffset);

                                    if (renderedAvatarItems.length > initialHiddenIndex && initialHiddenIndex >= 0 && renderedAvatarItems[initialHiddenIndex]) {
                                        // Apply hidden class only to the calculated avatar
                                        renderedAvatarItems.forEach((item, index) => {
                                            item.classList.toggle(SETTINGS.partiallyHiddenClass, index === initialHiddenIndex);
                                        });
                                    } else if (renderedAvatarItems.length <= layout.visibleAvatarsCount) {
                                        // If there aren't enough avatars to actually hide one, hide the count as well.
                                        if (countElement) countElement.style.display = 'none';
                                    }
                                }
                            }

                        } else {
                            // Scrolling Disabled (not enough unique avatars):
                            // Hide count, adjust viewport width to fit available avatars, remove listeners.
                            if (countElement) countElement.style.display = 'none';

                            // Calculate width needed for the available avatars (up to visible count)
                            const nonScrollingAvatarCount = Math.min(totalUniqueAvatars, layout.visibleAvatarsCount);
                            const nonScrollingWidth = layout.avatarSize + Math.max(0, nonScrollingAvatarCount - 1) * layout.avatarSlotWidth;
                            if (viewport) viewport.style.width = `${nonScrollingWidth}px`;

                            // Ensure no avatars are hidden if scrolling is off
                            renderedAvatarItems.forEach(item => item.classList.remove(SETTINGS.partiallyHiddenClass));

                            // Remove listeners if scrolling becomes disabled
                            document.removeEventListener('scroll', handlePageScroll);
                            if (container) {
                                container.removeEventListener('mouseenter', startHoverScroll);
                                container.removeEventListener('mouseleave', stopHoverScrollAndSnap);
                            }
                            // Ensure scroller is at the start position
                            if (scroller) scroller.style.transform = 'translateX(0px)';
                            currentScrollPosition = 0;
                        }

                    }); // End requestAnimationFrame for initialization
                }

                // --- Run Initialization & Setup Resize Listener ---

                // Initialize the component when the DOM is ready
                document.addEventListener('DOMContentLoaded', initializeAvatarGroup);

                // Add a debounced resize listener to re-initialize the component if the interaction mode changes
                // or if layout needs recalculation (e.g., CSS variables change via media queries).
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        // Re-run the full initialization to adapt to new screen size / mode / CSS variables
                        initializeAvatarGroup();
                    }, 250); // Debounce delay in milliseconds
                });

            })(); // End of IIFE
        </script>

    </body>

</html>